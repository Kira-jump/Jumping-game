<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Jumping â€” Stickman $JUMP v2</title>
<style>
  html,body{height:100%;margin:0;background:#d6edff;touch-action:none;-webkit-tap-highlight-color:transparent}
  #game{display:block;margin:0 auto;background:linear-gradient(to top,#97e661 50%,#50a5cb 100%);border-radius:14px;max-width:950px;width:100%;height:64vh;box-shadow:0 10px 34px rgba(0,0,0,0.19)}
  #ui{font-family:Inter,system-ui,Arial,sans-serif;color:#243;text-align:center;margin-top:12px;text-shadow:0 2px 4px #b1e09e55}
  .btn{display:inline-block;background:#fffa;padding:10px 18px;border-radius:8px;box-shadow:0 3px 8px rgba(0,0,0,.10);cursor:pointer;font-weight:600;letter-spacing:.04em;}
  #instructions{font-size:15px;color:#1885a1;margin-top:8px;text-shadow:none;}
  #coin-count{margin-left:18px;color:#a66e08;font-weight:800;font-size:15px;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div style="display:flex;justify-content:space-between;max-width:950px;margin:8px auto;">
    <div class="btn" id="playBtn">TAP POUR JOUER</div>
    <div style="font-weight:700">Score: <span id="score">0</span></div>
    <div id="coin-count">ðŸª™ 0</div>
  </div>
  <div id="instructions">Tape l'Ã©cran ou clique pour faire SAUTER le bonhomme ðŸ•º. Ã‰vite les obstacles et attrape les piÃ¨cesâ€¯!</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const playBtn = document.getElementById('playBtn');
  const coinEl = document.getElementById('coin-count');

  // Responsive canvas
  function resize(){
    canvas.width = Math.min(window.innerWidth,950);
    canvas.height = Math.max(340, Math.floor(window.innerHeight * 0.64));
  }
  window.addEventListener('resize', resize);
  resize();

  // Game variables
  let running = false;
  let score = 0;
  let speed = 3.2;
  let gravity = 1.08;
  let frame = 0;
  let best = 0;
  let coins = 0;
  let pieces = [];
  let obstacles = [];

  // Les types dâ€™obstacles
  const OBSTACLE_TYPES = [
    "flacon", // flacon d'eau
    "pneu",
    "table",
    "tronc",
    "borne", // borne d'incendie
    "trou"
  ];
  // GÃ©nÃ©rateur d'obstaclesÂ : switch pour dessiner chaque type.
  function spawnObstacle() {
    const type = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
    let h = 36 + Math.random()*52, w = 30 + Math.random()*26;
    let y = canvas.height - 92 - h;
    if(type === "trou") {
      w = 38 + Math.random()*55;
      h = 18;
      y = canvas.height - 75 - h/2;
    }
    obstacles.push({ x: canvas.width+20, y, w, h, type });
  }

  // GÃ©nÃ©rateur de piÃ¨ces
  function spawnCoins() {
    if (pieces.length >= 10) return;
    // GÃ©nÃ©rer ligne de piÃ¨ces, espace verticalÂ : 40px, variation hauteur
    const baseY = canvas.height - 150 - Math.random()*120;
    let baseX = canvas.width + 30;
    for(let i=0;i<10;i++) {
      pieces.push({
        x: baseX + i*38,
        y: baseY + Math.sin(i/1.5)*14,
        r: 13,
        collected: false
      });
    }
  }

  // Simple cartoon ground
  function drawCartoonGround() {
    // Ombre "flottante"
    ctx.beginPath();
    ctx.ellipse(canvas.width/2, canvas.height-57, canvas.width/2.6, 15, 0, 0, Math.PI*2);
    ctx.fillStyle = "#5a9444";
    ctx.globalAlpha = 0.17;
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // Bande principale cartoon
    ctx.beginPath();
    ctx.moveTo(0, canvas.height-62);
    for(let i=0;i<canvas.width;i+=54){
      ctx.lineTo(i+18,canvas.height-65-Math.sin(i/60)*9);
      ctx.lineTo(i+45,canvas.height-52+Math.sin(i/61)*9);
    }
    ctx.lineTo(canvas.width,canvas.height-32);
    ctx.lineTo(canvas.width,canvas.height);
    ctx.lineTo(0,canvas.height);
    ctx.closePath();
    ctx.fillStyle = "#7fd154";
    ctx.fill();

    // Bords
    ctx.beginPath();
    ctx.moveTo(0, canvas.height-62);
    ctx.lineTo(canvas.width, canvas.height-62);
    ctx.strokeStyle="#54762c";
    ctx.lineWidth = 2.2;
    ctx.stroke();
  }

  // Stickman pseudo-3D (rotation/jambes qui vont devant/ne derriÃ¨re, ombre Â«Â solÂ Â» en perspective)
  let lastDirection = 1; // Pour osciller bras/jambes faces "cam"
  const player = {
    x: 90,
    y: canvas.height - 180,
    w: 42,
    h: 64,
    vy: 0,
    jumping: false,
    angle: 0,
    draw() {
      ctx.save();
      ctx.translate(this.x + this.w / 2, this.y + this.h / 2);

      // OmbreÂ sol faÃ§on 3D
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.scale(1.55, 0.38);
      ctx.beginPath();
      ctx.ellipse(0, 140, 24, 13, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#262926";
      ctx.fill();
      ctx.restore();

      // Petite animation 3D simulÃ©e : on fait pivoter un peu les membres
      const sway = Math.sin(performance.now()/230) * 9 * (this.jumping ? 0.4 : 1);
      const jumpLeg = this.jumping ? 28 : 16 + sway;
      const jumpArm = this.jumping ? (16+sway*0.45) : (12+sway*0.3);

      // CorpsÂ : vertical + effet perspective
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineWidth = 5;
      ctx.rotate(sway/222);
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(0, 22);
      ctx.strokeStyle = "#232";
      ctx.stroke();

      // Jambes (devant/derriÃ¨re pour effet profondeur)
      // Jambe behind (gauche)
      ctx.beginPath();
      ctx.moveTo(0, 22);
      ctx.lineTo(-13, jumpLeg+36);
      ctx.strokeStyle = "#273";
      ctx.lineWidth = 5.6;
      ctx.globalAlpha = 0.6;
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Jambe devant (droite)
      ctx.beginPath();
      ctx.moveTo(0, 22);
      ctx.lineTo(13, jumpLeg+40);
      ctx.strokeStyle = "#383";
      ctx.lineWidth = 7;
      ctx.stroke();

      // TÃªteÂ : effet 3D ombrÃ©
      ctx.beginPath();
      ctx.arc(0, -20, 14, 0, Math.PI * 2);
      let grad = ctx.createRadialGradient(-6, -26, 7, 0, -20, 16);
      grad.addColorStop(0,"#fff6c2");
      grad.addColorStop(0.25,"#ffe7a3");
      grad.addColorStop(0.98,"#b59556");
      ctx.fillStyle = grad;
      ctx.strokeStyle = "#997333";
      ctx.fill();
      ctx.stroke();

      // Yeux et sourire
      ctx.beginPath();
      ctx.arc(-5, -22, 1.7, 0, Math.PI * 2);
      ctx.arc(5, -22, 1.6, 0, Math.PI * 2);
      ctx.fillStyle = "#222";
      ctx.fill();
      ctx.beginPath();
      ctx.strokeStyle = "#bb9966";
      ctx.lineWidth = 1.4;
      ctx.arc(0, -13.3, 5, 0, Math.PI, false);
      ctx.stroke();

      // Bras (derriÃ¨re, gauche)
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(-jumpArm-6, 14+sway*0.5);
      ctx.strokeStyle = "#383";
      ctx.lineWidth = 4.2;
      ctx.globalAlpha = 0.55;
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Bras devant (droit, plus Ã©pais)
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(jumpArm+11, 14-sway*0.6);
      ctx.strokeStyle = "#232";
      ctx.lineWidth = 5.2;
      ctx.stroke();

      ctx.restore();
      ctx.restore();
    },
    update() {
      this.vy += gravity;
      this.y += this.vy;
      const ground = canvas.height - 62;
      if (this.y + this.h > ground) {
        this.y = ground - this.h;
        this.vy = 0;
        this.jumping = false;
      }
    },
    jump() {
      if (!this.jumping) {
        this.vy = -17.5;
        this.jumping = true;
      }
    }
  };

  // Obstacle collision
  function collide(a, b){
    // hitbox simple pour la plupart (stickman & obstacle)
    return (
      a.x < b.x + b.w &&
      a.x + a.w > b.x &&
      a.y + 16 < b.y + b.h &&
      a.y + a.h > b.y+4
    );
  }

  // Trou (sol "trou") spÃ©cialÂ : y == sol et le joueur tombe
  function inHole(player, obs) {
    return (
      obs.type === 'trou' &&
      player.x + player.w > obs.x &&
      player.x < obs.x + obs.w &&
      (player.y + player.h > canvas.height - 72)
    );
  }

  // Dessin obstacles variÃ©s
  function drawObstacle(obs) {
    ctx.save();
    if(obs.type=="flacon") {
      // Flacon d'eau
      ctx.fillStyle="#b5e6fd";
      ctx.fillRect(obs.x, obs.y+obs.h-30, obs.w, 30);
      ctx.fillStyle="#7ac7e6";
      ctx.fillRect(obs.x+5, obs.y+5, obs.w-10, obs.h-35);
      ctx.strokeStyle="#69a9c8";
      ctx.lineWidth=3;
      ctx.strokeRect(obs.x,obs.y,obs.w,obs.h);
      ctx.beginPath();
      ctx.ellipse(obs.x+obs.w/2, obs.y+6, obs.w/3, 6, 0, 0, Math.PI*2);
      ctx.fillStyle="#d6ffff";
      ctx.globalAlpha=0.78;
      ctx.fill();
      ctx.globalAlpha=1;
    } else if(obs.type=="pneu") {
      // Pneu
      ctx.beginPath();
      ctx.ellipse(obs.x+obs.w/2, obs.y+obs.h-8, obs.w/2, obs.h/2, 0, 0, Math.PI*2);
      ctx.fillStyle="#34332a";
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(obs.x+obs.w/2, obs.y+obs.h-8, obs.w/3, obs.h/3, 0, 0, Math.PI*2);
      ctx.fillStyle="#555";
      ctx.fill();
    } else if(obs.type=="table") {
      // Table
      ctx.fillStyle="#ca995e";
      ctx.fillRect(obs.x, obs.y+obs.h-18, obs.w, 18);
      ctx.strokeStyle="#8a6028";
      ctx.lineWidth=5;
      ctx.beginPath();
      ctx.moveTo(obs.x+5,obs.y+obs.h-1);
      ctx.lineTo(obs.x+5,obs.y+obs.h-18);
      ctx.moveTo(obs.x+obs.w-5,obs.y+obs.h-1);
      ctx.lineTo(obs.x+obs.w-5,obs.y+obs.h-18);
      ctx.stroke();
      ctx.lineWidth=2.8;
      ctx.strokeStyle="#fff3";
    } else if(obs.type=="tronc") {
      // Tronc dâ€™arbre
      ctx.fillStyle="#884b19";
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.beginPath();
      ctx.arc(obs.x+obs.w/2, obs.y, obs.w/2, Math.PI, 0, false);
      ctx.fillStyle="#cfa06c";
      ctx.fill();
    } else if(obs.type=="borne") {
      // Borne incendie (rouge)
      ctx.beginPath();
      ctx.arc(obs.x+obs.w/2, obs.y+obs.h-17, 13, 0, Math.PI*2);
      ctx.fillStyle="#e54";
      ctx.fill();
      ctx.fillRect(obs.x+obs.w/2-11, obs.y+obs.h-17, 22, 15);
      ctx.fillRect(obs.x+obs.w/2-6, obs.y+obs.h-2, 12, 5);
    } else if(obs.type=="trou") {
      // trou noir
      ctx.beginPath();
      ctx.ellipse(obs.x+obs.w/2, canvas.height-52, obs.w/2, 8, 0, 0, Math.PI*2);
      ctx.fillStyle="#222";
      ctx.globalAlpha=0.88;
      ctx.fill();
      ctx.globalAlpha=1;
    }
    ctx.restore();
  }

  // Game reset
  function reset(){
    obstacles = [];
    pieces = [];
    score = 0;
    coins = 0;
    speed = 3.3;
    frame = 0;
    running = true;
  }

  // Game loop
  function loop(){
    if(!running) return;
    frame++;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background ground
    drawCartoonGround();

    // Score/ObstaclesÂ : rythme accÃ©lÃ¨re
    if(frame % Math.max(66, Math.floor(136 - score/6)) === 0){
      spawnObstacle();
    }
    // PiÃ¨ces tous les 25 pts (max 10 en mÃªme temps)
    if(score > 0 && score % 25 === 0 && pieces.length<1){
      spawnCoins();
    }

    // Update/draw obstacles
    for(let i=obstacles.length-1; i >= 0; i--){
      obstacles[i].x -= speed;
      drawObstacle(obstacles[i]);
      if (collide(player, obstacles[i]) || inHole(player, obstacles[i])) {
        running = false;
        playBtn.innerText = 'REJOUER';
        best = Math.max(best, score);
        gameOver();
        break;
      }
      // remove off-screen
      if(obstacles[i].x + obstacles[i].w < -60) obstacles.splice(i,1);
    }

    // Update/draw coins
    for(let i=pieces.length-1; i>=0; i--){
      const coin = pieces[i];
      coin.x -= speed;
      // detection collision
      if (
        !coin.collected &&
        player.x + player.w > coin.x-1 &&
        player.x < coin.x + coin.r*2 &&
        player.y+1 < coin.y + coin.r*2 &&
        player.y + player.h > coin.y-12
      ) {
        coin.collected=true; coins++; coinEl.innerText="ðŸª™ "+coins;
      }
      // draw coin
      if(!coin.collected){
        ctx.save();
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.r, 0, Math.PI*2);
        let cg=ctx.createRadialGradient(coin.x-6,coin.y-5,coin.r/4, coin.x,coin.y,coin.r);
        cg.addColorStop(0,"#fff8ab");
        cg.addColorStop(0.6,"#f1c90c");
        cg.addColorStop(1,"#b5871c");
        ctx.fillStyle = cg;
        ctx.strokeStyle = "#775a08";
        ctx.lineWidth=2.1;
        ctx.shadowColor="#fd3";
        ctx.shadowBlur=7;
        ctx.fill(); ctx.stroke(); ctx.restore();
      }
      // remove if off-screen or collected
      if (coin.x < -35 || coin.collected) pieces.splice(i,1);
    }

    // update player
    player.update();
    player.draw();

    // score and speed
    if(frame % 6 === 0) { score++; scoreEl.innerText = score; }
    speed = 3.2 + Math.min(7, Math.floor(score/24));

    requestAnimationFrame(loop);
  }

  // Input
  function tapHandler(e){
    e.preventDefault();
    if(!running){
      reset();
      loop();
      coinEl.innerText="ðŸª™ 0";
    }
    player.jump();
  }
  canvas.addEventListener('touchstart', tapHandler, {passive:false});
  canvas.addEventListener('mousedown', tapHandler);

  playBtn.addEventListener('click', () => {
    if(!running){
      reset();
      loop();
      coinEl.innerText="ðŸª™ 0";
    } else {
      player.jump();
    }
  });

  // Game over overlay
  function gameOver(){
    ctx.fillStyle = 'rgba(0,0,0,0.46)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '32px sans-serif';
    ctx.fillText('Game Over ðŸ•º', canvas.width/2, canvas.height/2 - 22);
    ctx.font = '19px sans-serif';
    ctx.fillText('Score: ' + score + '  â€¢  Meilleur: ' + best, canvas.width/2, canvas.height/2 + 18);
    ctx.font = '17px sans-serif';
    ctx.fillText('ðŸª™ PiÃ¨ces ramassÃ©es: ' + coins, canvas.width/2, canvas.height/2 + 44);
  }

  // Expose pour debug/cheat
  window.JUMPING = { getScore: ()=>score, getBest: ()=>best, getCoins:()=>coins };

  // First frame draw
  drawCartoonGround();
  player.draw();
})();
</script>
</body>
</html>
