<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Cartoon Runner - Kira (Full)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html,body { height:100%; margin:0; background:#87CEFA; font-family: Arial, Helvetica, sans-serif; -webkit-tap-highlight-color: transparent; }
  #game-container{ width:100%; height:100vh; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; }
  canvas { max-width:100%; height:auto; display:block; margin:0 auto; }
  .ui-overlay { position:absolute; left:12px; top:12px; color:#111; z-index:50; pointer-events:none; }
  .mobile-controls { position:absolute; left:0; bottom:20px; width:100%; display:flex; justify-content:space-between; padding:0 20px; pointer-events:none; z-index:60; }
  .touch-btn { width:96px; height:96px; border-radius:16px; background:rgba(0,0,0,0.25); display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; font-size:20px; pointer-events:auto; user-select:none; -webkit-user-select:none; }
  .center-ui { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:60; text-align:center; }
  .menu-button { display:inline-block; margin:8px; padding:12px 20px; border-radius:12px; background:#ffcc33; color:#111; font-weight:bold; cursor:pointer; border:4px solid rgba(255,255,255,0.2); box-shadow:0 8px 0 rgba(0,0,0,0.15); }
  .menu-small { background:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; }
</style>
</head>
<body>
<div id="game-container"></div>

<!-- UI copy for fallback info -->
<div class="ui-overlay" id="uiOverlay"></div>

<!-- Phaser 3 -->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

<script>
// ---------------- CONFIG ----------------
const WIDTH = 900, HEIGHT = 500;
const ASSET_BASE = 'assets/';
const SPRITE_FRAME = 512;
const RUN_FRAMES = 8, JUMP_FRAMES = 4, IDLE_FRAMES = 4, SLIDE_FRAMES = 4;

// Expected files (same as earlier)
const ASSETS = {
  player_run: ASSET_BASE + 'sprites/player_run.png',
  player_jump: ASSET_BASE + 'sprites/player_jump.png',
  player_idle: ASSET_BASE + 'sprites/player_idle.png',
  player_slide: ASSET_BASE + 'sprites/player_slide.png',
  coin: ASSET_BASE + 'sprites/coin.png',
  obstacle: ASSET_BASE + 'sprites/obstacle.png',
  bg1: ASSET_BASE + 'bg/bg_layer1.png',
  bg2: ASSET_BASE + 'bg/bg_layer2.png',
  bg3: ASSET_BASE + 'bg/bg_layer3.png',
  music: ASSET_BASE + 'sfx/music_loop.mp3',
  sfx_jump: ASSET_BASE + 'sfx/sfx_jump.wav',
  sfx_coin: ASSET_BASE + 'sfx/sfx_coin.wav',
  sfx_hit: ASSET_BASE + 'sfx/sfx_hit.wav',
  sfx_button: ASSET_BASE + 'sfx/sfx_button.wav'
};

// ---------------- PHASER CONFIG ----------------
const gameConfig = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: WIDTH,
  height: HEIGHT,
  backgroundColor: 0x87cefa,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 1200 }, debug: false }
  },
  scene: [BootScene, MenuScene, GameScene, UIScene]
};
const game = new Phaser.Game(gameConfig);

// ---------------- BOOT SCENE ----------------
function BootScene() { Phaser.Scene.call(this, { key: 'BootScene' }); }
BootScene.prototype = Object.create(Phaser.Scene.prototype);
BootScene.prototype.constructor = BootScene;
BootScene.prototype.preload = function() {
  // Try loading assets; we'll create placeholders in create() if missing
  this.load.spritesheet('player_run', ASSETS.player_run, { frameWidth: SPRITE_FRAME, frameHeight: SPRITE_FRAME });
  this.load.spritesheet('player_jump', ASSETS.player_jump, { frameWidth: SPRITE_FRAME, frameHeight: SPRITE_FRAME });
  this.load.spritesheet('player_idle', ASSETS.player_idle, { frameWidth: SPRITE_FRAME, frameHeight: SPRITE_FRAME });
  this.load.spritesheet('player_slide', ASSETS.player_slide, { frameWidth: SPRITE_FRAME, frameHeight: SPRITE_FRAME });
  this.load.image('coin', ASSETS.coin);
  this.load.image('obst', ASSETS.obstacle);
  this.load.image('bg1', ASSETS.bg1);
  this.load.image('bg2', ASSETS.bg2);
  this.load.image('bg3', ASSETS.bg3);
  this.load.audio('music', ASSETS.music);
  this.load.audio('jump', ASSETS.sfx_jump);
  this.load.audio('coin', ASSETS.sfx_coin);
  this.load.audio('hit', ASSETS.sfx_hit);
  this.load.audio('btn', ASSETS.sfx_button);

  // small progress text
  const txt = this.add.text(this.scale.width/2, this.scale.height/2, 'Loading...', { font: '20px Arial', color:'#111' }).setOrigin(0.5);
  this.load.on('progress', (p) => { txt.setText('Loading... ' + Math.round(p*100) + '%'); });
  this.load.on('complete', () => {});
};

BootScene.prototype.create = function() {
  // create placeholders for any missing texture
  ensurePlaceholder(this, 'player_run', SPRITE_FRAME, SPRITE_FRAME, RUN_FRAMES);
  ensurePlaceholder(this, 'player_jump', SPRITE_FRAME, SPRITE_FRAME, JUMP_FRAMES);
  ensurePlaceholder(this, 'player_idle', SPRITE_FRAME, SPRITE_FRAME, IDLE_FRAMES);
  ensurePlaceholder(this, 'player_slide', SPRITE_FRAME, SPRITE_FRAME, SLIDE_FRAMES);
  if (!this.textures.exists('coin')) createCircleTexture(this, 'coin', 64, 0xf2d12b);
  if (!this.textures.exists('obst')) createRectTexture(this, 'obst', 140, 120, 0x5c5c5c);

  // music options stored in localStorage default if missing
  if (localStorage.getItem('cr_music') === null) localStorage.setItem('cr_music', '1');
  if (localStorage.getItem('cr_sfx') === null) localStorage.setItem('cr_sfx', '1');

  this.scene.start('MenuScene');
};

// ---------------- MENU SCENE ----------------
function MenuScene() { Phaser.Scene.call(this, { key: 'MenuScene' }); }
MenuScene.prototype = Object.create(Phaser.Scene.prototype);
MenuScene.prototype.constructor = MenuScene;
MenuScene.prototype.create = function() {
  const s = this;
  // background (simple)
  if (this.textures.exists('bg1')) this.add.tileSprite(0,0,WIDTH,HEIGHT,'bg1').setOrigin(0).setScrollFactor(0);
  this.add.text(WIDTH/2, 80, 'Cartoon Runner', { font: '48px Arial', color:'#111', fontStyle:'bold' }).setOrigin(0.5);
  // buttons (DOM-like using Phaser text objects clickable)
  const start = this.add.text(WIDTH/2, 200, 'START', { font:'28px Arial', color:'#111', background:'#ffcc33', padding:{x:20,y:10} }).setOrigin(0.5).setInteractive();
  const options = this.add.text(WIDTH/2, 260, 'OPTIONS', { font:'20px Arial', color:'#111', background:'#fff', padding:{x:12,y:8} }).setOrigin(0.5).setInteractive();
  const credits = this.add.text(WIDTH/2, 310, 'CREDITS', { font:'18px Arial', color:'#111', background:'#fff', padding:{x:12,y:8} }).setOrigin(0.5).setInteractive();

  // highscore display
  const hs = localStorage.getItem('cr_highscore') || 0;
  this.add.text(WIDTH/2, 360, 'Best: ' + hs, { font:'18px Arial', color:'#111' }).setOrigin(0.5);

  // sfx button small
  const sfxToggle = this.add.text(WIDTH - 150, 20, 'SFX: ' + (localStorage.getItem('cr_sfx') === '1' ? 'ON' : 'OFF'), { font:'16px Arial', color:'#111', background:'#fff', padding:{x:8,y:6} }).setOrigin(0.5).setInteractive();
  const musicToggle = this.add.text(WIDTH - 60, 20, 'M: ' + (localStorage.getItem('cr_music') === '1' ? 'ON' : 'OFF'), { font:'16px Arial', color:'#111', background:'#fff', padding:{x:8,y:6} }).setOrigin(0.5).setInteractive();

  start.on('pointerdown', () => {
    playBtn(this);
    this.scene.start('GameScene');
  });
  options.on('pointerdown', () => {
    playBtn(this);
    showOptions(this);
  });
  credits.on('pointerdown', () => {
    playBtn(this);
    alert('Made by Kira - Cartoon Runner\nPush to GitHub Pages to publish.');
  });
  sfxToggle.on('pointerdown', () => {
    const cur = localStorage.getItem('cr_sfx') === '1';
    localStorage.setItem('cr_sfx', cur ? '0' : '1');
    sfxToggle.setText('SFX: ' + (localStorage.getItem('cr_sfx') === '1' ? 'ON' : 'OFF'));
    playBtn(this);
  });
  musicToggle.on('pointerdown', () => {
    const cur = localStorage.getItem('cr_music') === '1';
    localStorage.setItem('cr_music', cur ? '0' : '1');
    musicToggle.setText('M: ' + (localStorage.getItem('cr_music') === '1' ? 'ON' : 'OFF'));
    playBtn(this);
  });

  // small instructions
  this.add.text(WIDTH/2, HEIGHT - 40, 'Espace/Tap: Jump â€¢ Swipe/Down: Slide', { font:'14px Arial', color:'#111' }).setOrigin(0.5);
};

// ---------------- UI / OVERLAY SCENE (optional overlay, but included later) ----------------
function UIScene() { Phaser.Scene.call(this, { key: 'UIScene', active:false }); }
UIScene.prototype = Object.create(Phaser.Scene.prototype);
UIScene.prototype.constructor = UIScene;

// ---------------- GAME SCENE ----------------
function GameScene() { Phaser.Scene.call(this, { key: 'GameScene' }); }
GameScene.prototype = Object.create(Phaser.Scene.prototype);
GameScene.prototype.constructor = GameScene;

GameScene.prototype.create = function() {
  const scene = this;
  this.speed = 6;         // base speed (increases)
  this.difficultyTimer = 0;
  this.spawnInterval = 1400; // ms
  this.lastSpawn = 0;
  this.score = 0;
  this.lives = 3;
  this.isPaused = false;

  // music
  this.music = this.sound.add('music', { loop:true, volume:0.5 });
  if (localStorage.getItem('cr_music') === '1') { if (!this.music.isPlaying) this.music.play(); }

  // sfx references
  this.sfxJump = this.sound.add('jump', { volume:0.8 });
  this.sfxCoin = this.sound.add('coin', { volume:0.9 });
  this.sfxHit  = this.sound.add('hit', { volume:0.9 });
  this.sfxBtn  = this.sound.add('btn', { volume:0.9 });

  // background parallax
  if (this.textures.exists('bg1')) this.bg1 = this.add.tileSprite(0,0,WIDTH,HEIGHT,'bg1').setOrigin(0).setScrollFactor(0);
  if (this.textures.exists('bg2')) this.bg2 = this.add.tileSprite(0,40,WIDTH,200,'bg2').setOrigin(0).setScrollFactor(0);
  if (this.textures.exists('bg3')) this.bg3 = this.add.tileSprite(0,200,WIDTH,300,'bg3').setOrigin(0).setScrollFactor(0);

  // ground
  const GROUND_Y = 400;
  this.add.rectangle(0, GROUND_Y, WIDTH, HEIGHT-GROUND_Y, 0x3c3c3c).setOrigin(0);

  // Create player
  this.player = this.physics.add.sprite(150, 360, 'player_run').setOrigin(0.5,1);
  this.player.setScale(0.22);
  this.player.setCollideWorldBounds(true);
  this.player.body.setSize(200, 340);
  this.player.state = 'run';

  // animations
  createAnimIfExists(this, 'run', 'player_run', RUN_FRAMES, 14, -1);
  createAnimIfExists(this, 'jump', 'player_jump', JUMP_FRAMES, 12, 0);
  createAnimIfExists(this, 'idle', 'player_idle', IDLE_FRAMES, 6, -1);
  createAnimIfExists(this, 'slide', 'player_slide', SLIDE_FRAMES, 12, 0);
  playAnim(this, 'run');

  // groups
  this.obstacles = this.physics.add.group();
  this.coins = this.physics.add.group();

  // collider
  this.physics.add.collider(this.player, this.obstacles, (p,o) => {
    o.destroy();
    this.lives -= 1;
    playSfx(this, 'hit');
    if (this.lives <= 0) endGame(this);
  }, null, this);

  this.physics.add.overlap(this.player, this.coins, (p,c) => {
    c.destroy();
    this.score += 10;
    playSfx(this, 'coin');
  }, null, this);

  // input: keyboard and touch
  this.input.keyboard.on('keydown-SPACE', () => { playerJump(this); });
  this.input.keyboard.on('keydown-DOWN', () => { playerSlide(this); });
  // touch buttons: create HTML-like overlay elements using DOM inside game container
  createMobileControls(this);

  // HUD text
  this.scoreText = this.add.text(12,12,`Score: ${this.score}  Lives: ${this.lives}`, { font:'20px Arial', color:'#111' }).setDepth(50);

  // pause on focus lost (mobile)
  window.addEventListener('blur', () => { if (!this.isPaused) togglePause(this, true); });
};

GameScene.prototype.update = function(time, delta) {
  if (this.isPaused) return;
  const dt = delta/1000;

  // parallax speed depends on game speed
  if (this.bg1) this.bg1.tilePositionX += this.speed * 0.3;
  if (this.bg2) this.bg2.tilePositionX += this.speed * 0.6;
  if (this.bg3) this.bg3.tilePositionX += this.speed * 1.0;

  // increase difficulty gradually
  this.difficultyTimer += delta;
  if (this.difficultyTimer > 5000) { // every 5s
    this.difficultyTimer = 0;
    this.speed += 0.5; // increase world speed
    this.spawnInterval = Math.max(700, this.spawnInterval - 80); // faster spawns, min cap
  }

  // spawn obstacles/coins
  this.lastSpawn += delta;
  if (this.lastSpawn >= this.spawnInterval) {
    spawnWave(this);
    this.lastSpawn = 0;
  }

  // move obstacles/coins
  Phaser.Actions.IncX(this.obstacles.getChildren(), -Math.round(this.speed));
  Phaser.Actions.IncX(this.coins.getChildren(), -Math.round(this.speed));
  // cleanup
  this.obstacles.getChildren().forEach(o => { if (o.x + o.width < -50) o.destroy(); });
  this.coins.getChildren().forEach(c => { if (c.x + c.width < -50) c.destroy(); });

  // update player animation state
  if (this.player.body.onFloor()) {
    if (this.player.state !== 'run') { playAnim(this, 'run'); this.player.state = 'run'; }
  } else {
    if (this.player.state !== 'jump') { playAnim(this, 'jump'); this.player.state = 'jump'; }
  }
  // update HUD
  this.scoreText.setText(`Score: ${this.score}  Lives: ${this.lives}`);
};

// ---------------- HELPERS & GAME LOGIC ----------------
function playerJump(scene) {
  if (!scene.player) return;
  if (scene.player.body.onFloor()) {
    scene.player.setVelocityY(-540);
    playSfx(scene, 'jump');
    playAnim(scene, 'jump');
    scene.player.state = 'jump';
  }
}
function playerSlide(scene) {
  if (!scene.player) return;
  if (scene.player.body.onFloor()) {
    playAnim(scene, 'slide');
    scene.player.state = 'slide';
    // short slide effect - smaller hitbox
    scene.player.body.setSize(220, 140);
    scene.time.delayedCall(450, () => {
      scene.player.body.setSize(200, 340);
      scene.player.state = 'run';
      playAnim(scene, 'run');
    });
  }
}

function spawnWave(scene) {
  const x = WIDTH + 120 + Math.floor(Math.random()*160);
  // obstacle
  let obst;
  if (scene.textures.exists('obst')) {
    obst = scene.physics.add.image(x, 400, 'obst').setOrigin(0,1);
    obst.setScale(0.6);
  } else {
    obst = scene.physics.add.image(x, 400, null).setOrigin(0,1);
    createRectTexture(scene, 'obst', 80, 90, 0x5c5c5c);
    obst.setTexture('obst');
  }
  obst.body.setImmovable(true); obst.body.allowGravity = false;
  scene.obstacles.add(obst);
  // coins line occasionally above
  if (Math.random() < 0.85) {
    const cols = 3;
    for (let i=0;i<cols;i++){
      const cx = x + 120 + i*40;
      const cy = 300 - i*10;
      let coin;
      if (scene.textures.exists('coin')) {
        coin = scene.physics.add.image(cx, cy, 'coin').setScale(0.5);
      } else {
        createCircleTexture(scene, 'coin', 28, 0xf2d12b);
        coin = scene.physics.add.image(cx, cy, 'coin').setScale(0.6);
      }
      coin.body.allowGravity = false;
      scene.coins.add(coin);
    }
  }
  // reward for surviving: small +score each spawn
  scene.score += Math.floor(scene.speed);
}

function endGame(scene) {
  // stop spawns and music; show Game Over UI; save highscore
  if (scene.music && scene.music.isPlaying) scene.music.stop();
  // stop spawn by switching to paused state
  scene.isPaused = true;
  const hs = Number(localStorage.getItem('cr_highscore') || 0);
  if (scene.score > hs) localStorage.setItem('cr_highscore', scene.score);
  // show overlay using DOM-like HTML (Phaser text)
  const goText = scene.add.text(WIDTH/2, HEIGHT/2 - 60, 'GAME OVER', { font:'36px Arial', color:'#ff0000' }).setOrigin(0.5).setDepth(100);
  const resume = scene.add.text(WIDTH/2, HEIGHT/2, 'RESTART', { font:'22px Arial', color:'#111', background:'#ffcc33', padding:{x:12,y:8} }).setOrigin(0.5).setInteractive().setDepth(100);
  const menu = scene.add.text(WIDTH/2, HEIGHT/2 + 60, 'MAIN MENU', { font:'18px Arial', color:'#111', background:'#fff', padding:{x:10,y:8} }).setOrigin(0.5).setInteractive().setDepth(100);
  resume.on('pointerdown', () => {
    playBtn(scene);
    scene.scene.restart(); // restart scene
  });
  menu.on('pointerdown', () => {
    playBtn(scene);
    scene.scene.start('MenuScene');
  });
}

// audio play helper with SFX toggle
function playSfx(scene, key) {
  if (localStorage.getItem('cr_sfx') !== '1') return;
  const s = { 'jump': scene.sfxJump, 'coin': scene.sfxCoin, 'hit': scene.sfxHit, 'btn': scene.sfxBtn }[key];
  if (s) s.play();
}
function playBtn(scene) { if (localStorage.getItem('cr_sfx') === '1' && scene.sfxBtn) scene.sfxBtn.play(); }

// create mobile controls overlaid as DOM elements (pointer events)
function createMobileControls(scene) {
  const container = document.getElementById('game-container');
  if (!container) return;
  // left: jump, right: slide
  const wrapper = document.createElement('div'); wrapper.className = 'mobile-controls';
  // left (jump)
  const leftBtn = document.createElement('div'); leftBtn.className = 'touch-btn'; leftBtn.style.marginLeft = '12px'; leftBtn.innerHTML = 'JUMP';
  leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); playerJump(scene); leftBtn.style.background = 'rgba(255,200,50,0.9)'; });
  leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); leftBtn.style.background = 'rgba(0,0,0,0.25)'; });
  // right (slide)
  const rightBtn = document.createElement('div'); rightBtn.className = 'touch-btn'; rightBtn.style.marginRight = '12px'; rightBtn.innerHTML = 'SLIDE';
  rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); playerSlide(scene); rightBtn.style.background = 'rgba(255,200,50,0.9)'; });
  rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); rightBtn.style.background = 'rgba(0,0,0,0.25)'; });

  wrapper.appendChild(leftBtn);
  wrapper.appendChild(rightBtn);
  container.appendChild(wrapper);
}

// ---------------- UTIL: Placeholders & Textures ----------------
function ensurePlaceholder(scene, key, fw, fh, frames) {
  if (scene.textures.exists(key)) return;
  // create a single texture that contains frames horizontally
  const W = fw*frames, H = fh;
  const g = scene.make.graphics({ x:0,y:0, add:false });
  for (let i=0;i<frames;i++){
    const x = i*fw;
    const hue = Math.floor(200 - i*(120/frames));
    g.fillStyle(Phaser.Display.Color.GetColor(hue, 180, 220), 1);
    g.fillRoundedRect(x+8, 8, fw-16, fh-16, 24);
    g.fillStyle(0x222222, 1);
    g.fillCircle(x+fw*0.5, fh*0.45, fw*0.16);
    g.fillRect(x+fw*0.5 - fw*0.08, fh*0.55, fw*0.16, fw*0.32);
    g.fillStyle(0xffffff,1); g.fillCircle(x+fw*0.47, fh*0.44, fw*0.03); g.fillCircle(x+fw*0.53, fh*0.44, fw*0.03);
  }
  g.generateTexture(key, W, H);
  g.destroy();
}
function createRectTexture(scene, key, w, h, color) {
  if (scene.textures.exists(key)) return;
  const g = scene.make.graphics({ add:false });
  g.fillStyle(color,1); g.fillRoundedRect(0,0,w,h,8);
  g.lineStyle(6,0xffffff,0.08); g.strokeRoundedRect(0,0,w,h,8);
  g.generateTexture(key, w, h);
  g.destroy();
}
function createCircleTexture(scene, key, d, color) {
  if (scene.textures.exists(key)) return;
  const g = scene.make.graphics({ add:false });
  g.fillStyle(color,1); g.fillCircle(d/2,d/2,d/2);
  g.lineStyle(4,0xffffff,0.15); g.strokeCircle(d/2,d/2,d/2 - 2);
  g.generateTexture(key, d, d);
  g.destroy();
}

// ---------------- SMALL UTIL FUNCTIONS (anims, playAnim, options menu) ----------------
function createAnimIfExists(scene, animKey, texKey, frames, rate, repeat) {
  if (!scene.textures.exists(texKey)) return;
  scene.anims.create({ key: animKey, frames: scene.anims.generateFrameNumbers(texKey, { start: 0, end: frames-1 }), frameRate: rate, repeat: repeat });
}
function playAnim(scene, key) { if (!scene.anims.exists(key)) return; scene.player.anims.play(key, true); }

// options modal (simple)
function showOptions(scene) {
  const currMusic = localStorage.getItem('cr_music') === '1';
  const currSfx = localStorage.getItem('cr_sfx') === '1';
  const answer = confirm(`Options:\nMusic: ${currMusic ? 'ON' : 'OFF'}\nSFX: ${currSfx ? 'ON' : 'OFF'}\n\nOK = toggle Music\nCancel = toggle SFX`);
  if (answer) {
    localStorage.setItem('cr_music', currMusic ? '0' : '1');
    if ((localStorage.getItem('cr_music') === '1') && scene.music && !scene.music.isPlaying) scene.music.play();
    if (localStorage.getItem('cr_music') === '0' && scene.music && scene.music.isPlaying) scene.music.stop();
  } else {
    localStorage.setItem('cr_sfx', currSfx ? '0' : '1');
  }
  playBtn(scene);
}

// small sfx play from MenuScene
function playBtn(scene) {
  if (scene.sound && localStorage.getItem('cr_sfx') === '1') { const btn = scene.sound.get('btn'); if (btn) btn.play(); }
}

// ---------------- Scenes registration (definitions above) ----------------
/* - empty; actual classes defined earlier and referenced in config - */

// ---------------- GITHUB PAGES / DEPLOY NOTES (display in console) ----------------
console.log("Cartoon Runner ready. To publish on GitHub Pages: place this file in '/' or '/docs' and enable Pages in repository settings.");

// End of script
</script>
</body>
</html>
